<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="tanjo">
    <title>filters.js</title>
    <link rel="stylesheet" type="text/css" href="index.css">
  </head>
  <body id="container">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/89/three.min.js"></script>
    <!-- HDR fragment shader -->
		<script id="fs-negative" type="x-shader/x-fragment">
      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      void main() {
        vec4 color = texture2D(tDiffuse, vUv);
        gl_FragColor = vec4(1.0 - color.x, 1.0 - color.y, 1.0 - color.z, 1.0);
      }
		</script>
    <script id="fs-mosaic" type="x-shader/x-fragment">
      varying vec2, vUv;
      uniform sampler2D tDiffuse;
      uniform vec2 vScreenSize;
      uniform float fMosaicScale;
      void main() {
        vec2 vUv2 = vUv;
        vUv2.x = floor(vUv.x  * vScreenSize.x / fMosaicScale) / (vScreenSize.x / fMosaicScale) + (fMosaicScale/2.0) / vScreenSize.x;
        vUv2.y = floor(vUv.y  * vScreenSize.y / fMosaicScale) / (vScreenSize.y / fMosaicScale) + (fMosaicScale/2.0) / vScreenSize.y;
        vec4 color = texture2D(tDiffuse, vUv2);
        gl_FragColor = color;
      }
    </script>
		<!-- HDR vertex shader -->
		<script id="vs" type="x-shader/x-vertex">
			varying vec2 vUv;
			void main()	{
				vUv  = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>
    <!-- Script -->
    <script>
			var container;
			var camera, scene, renderer;
			var materialHDR, quad;
			var sign = 1, rate = 1;
			var clock = new THREE.Clock();
      setup();
			load("https://tanjoin.github.io/vectors/img/memorial.png");
      function setup() {
        container = document.getElementById( 'container' );
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 900;
				scene = new THREE.Scene();
      }
			function load(file) {
				new THREE.TextureLoader().load( file, function(texture) {
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.NearestFilter;
          var size = {
            x: texture.image.width,
            y: texture.image.height
          };
          var aspect = window.innerHeight / size.height;
          if (size.y > window.innerHeight) {
            size.y = window.innerHeight;
            size.x = size.x * aspect;
          }
          materialHDR = new THREE.ShaderMaterial( {
            uniforms: {
              tDiffuse:  { value: texture },
              exposure:  { value: 0.125 },
              brightMax: { value: 0.5 },
              vScreenSize: { value: new THREE.Vector2(size.x, size.y)},
              fMosaicScale: { value: 15 }
            },
            vertexShader: document.getElementById('vs').textContent,
            fragmentShader: document.getElementById( 'fs-mosaic' ).textContent
          } );
          var plane = new THREE.PlaneBufferGeometry(size.x, size.y);
          quad = new THREE.Mesh( plane, materialHDR );
          quad.position.z = -100;
          scene.add( quad );
          renderer = new THREE.WebGLRenderer();
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          container.appendChild( renderer.domElement );
          //
          window.addEventListener( 'resize', onWindowResize, false );
          renderer.render( scene, camera );
        } );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
		</script>
  </body>
</html>
